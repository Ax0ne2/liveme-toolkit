import { Injectable, EventEmitter } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { ElectronService } from 'app/services/electron.service';

import * as pProgress from 'p-progress';
import * as pMap from 'p-map';

export interface Playlist {
    userid: string;
    username: string;
    videoid: string;
    videotitle: string;
    videotime: number;
    m3u8: string;

    progress?: number;
    downloadedChunks?: number;
    totalChunks?: number;
    status?: string;

    chunkProgress?: Map<string, number>;
}

@Injectable()
export class DownloadService {
    QUEUE: Playlist[] = [];
    ACTIVE: Playlist;

    isPaused: boolean = false;
    isVisible: boolean = false;

    private FFMPEG_COMMAND: string = '{FFMPEG} -f concat -safe 0 -i "{CONCAT}" -c copy "{DEST}"'; // todo add other commands

    constructor(
        private http: HttpClient,
        private electron: ElectronService
    ) { }

    addToQueue(p: Playlist) {
        p.status = 'queued';
        p.downloadedChunks = 0;
        p.totalChunks = 0;
        p.progress = 0;
        p.chunkProgress = new Map<string, number>();

        this.QUEUE.push(p);
        this.loop();
    }

    removeFromQueue(p: Playlist) {
        //this.QUEUE.delete(p.videoid);
    }

    async loop() {
        if (this.isPaused || this.ACTIVE) return;

        while (this.QUEUE.length > 0) {
            this.ACTIVE = this.QUEUE.shift();

            await this._processActiveItem().then(() => {
                this.ACTIVE = null;
            }).catch(err => {
                this.ACTIVE = null;
                console.error(err);
            });
        }
    }

    private _getUrls(): Promise<string[]> {
        this.ACTIVE.status = 'finding chunks...';

        return this.http.get(this.ACTIVE.m3u8, { responseType: 'text' })
            .toPromise()
            .then(response => {
                let playlist = [], baseURL = this.electron.path.dirname(this.ACTIVE.m3u8);

                for (let line of (response.split('\n'))) {

                    line = line.trim();

                    if (line.length == 0 || line[0] == '#') {
                        continue;
                    }

                    line = line.split('?').shift();
                    line = `${baseURL}/${line}`;

                    if (playlist.indexOf(line) != -1) {
                        continue;
                    }

                    playlist.push(line);
                }

                this.ACTIVE.totalChunks = playlist.length;
                return playlist;
            });
    }

    private _updateProgress() {
        let total = 0;

        for (let val of this.ACTIVE.chunkProgress.values()) {
            if (val)
                total += val;
        }

        this.ACTIVE.progress = Math.floor((total / this.ACTIVE.totalChunks) * 100);
    }

    private _downloadChunk(url: string, destination: string) {
        return new Promise((resolve, reject) => {
            this.electron.fs.ensureDirSync(this.electron.path.dirname(destination));
            let download = this.electron.wget.download(url, destination);

            download.on('error', err => reject(err));
            download.on('end', output => resolve(destination));
            download.on('progress', p => {
                this.ACTIVE.chunkProgress.set(url, p);
                this._updateProgress();
            });
        }).then(dest => {
            console.log('Downloaded ' + dest);
            this.ACTIVE.downloadedChunks++;
            this.ACTIVE.status = `downloading chunks [${this.ACTIVE.downloadedChunks}/${this.ACTIVE.totalChunks}]`;
            return dest;
        }).catch(err => {
            console.error('Caught ', err, ' from _downloadChunk');
        });
    }

    private _mergeFiles(files: string[]): Promise<void> {
        return new Promise((resolve, reject) => {
            this.ACTIVE.status = 'merging chunks...';
            let destination = this._getFinalFile();

            if (files.length == 1) {
                if (this.electron.fs.existsSync(destination)) {
                    this.electron.fs.removeSync(destination);
                }

                this.electron.fs.moveSync(files[0], destination);
                return resolve();
            }

            let concatStr = '# Generated by LiveMe Toolkit', concatPath = this._getTempFile('concat.txt');

            for (let file of files) {
                concatStr += `\nfile '${file}'`;
            }

            this.electron.fs.writeFileSync(concatPath, concatStr);
            let fmpeg = this.electron.settings.get('download.ffmpeg');

            if (fmpeg.indexOf(' ') != -1) {
                fmpeg = `"${fmpeg}"`;
            }
            
            let ffmpeg = this.FFMPEG_COMMAND
                .replace('{FFMPEG}', fmpeg)
                .replace('{CONCAT}', concatPath)
                .replace('{DEST}', destination);

            this.electron.fs.ensureDirSync(this.electron.path.dirname(destination));

            this.electron.exec(ffmpeg, (error, stdout, stderr) => {
                if (error) return reject(error);
                return resolve();
            });
        });
    }

    private _processActiveItem(): Promise<void> {
        this.ACTIVE.status = 'downloading';

        return this
            ._getUrls()
            .then((urls: string[]) => {
                this.ACTIVE.status = `downloading chunks [${this.ACTIVE.downloadedChunks}/${this.ACTIVE.totalChunks}]`;
                let mapper = el => this._downloadChunk(el, this._getTempFile(el));
                return pMap(urls, mapper, { concurrency: 4 });
            })
            .then(localFiles => this._mergeFiles(localFiles))
            .then(() => this._cleanupTempFiles());
    }

    private _cleanupTempFiles(): Promise<void> {
        this.ACTIVE.status = 'cleaning up temporary files';

        return new Promise((resolve, reject) => {
            let dir = this._getTempFile('', false);

            try {
                this.electron.fs.removeSync(dir);
                return resolve();
            } catch (e) {
                this.ACTIVE.status = 'ffmpeg is still using the files, waiting for a few seconds to retry';

                setTimeout(() => {
                    return this._cleanupTempFiles();
                }, 4000);
            }
        });
    }

    private _getFinalFile(): string {
        return this.electron.path.join(this.electron.settings.get('download.path'), 'test.mp4');
    }

    private _getTempFile(url: string, file: boolean = true): string {
        let filename = file ? this.electron.path.basename(url) : '';
        return this.electron.path.join(this.electron.settings.get('download.path'), 'temp', this.ACTIVE.videoid, filename);
    }
}